<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SNaQ.jl</title><meta name="title" content="Home · SNaQ.jl"/><meta property="og:title" content="Home · SNaQ.jl"/><meta property="twitter:title" content="Home · SNaQ.jl"/><meta name="description" content="Documentation for SNaQ.jl."/><meta property="og:description" content="Documentation for SNaQ.jl."/><meta property="twitter:description" content="Documentation for SNaQ.jl."/><meta property="og:url" content="https://JuliaPhylo.github.io/SNaQ.jl/"/><meta property="twitter:url" content="https://JuliaPhylo.github.io/SNaQ.jl/"/><link rel="canonical" href="https://JuliaPhylo.github.io/SNaQ.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img class="docs-light-only" src="assets/logo.png" alt="SNaQ.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="SNaQ.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>SNaQ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/dev/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SNaQ"><a class="docs-heading-anchor" href="#SNaQ">SNaQ</a><a id="SNaQ-1"></a><a class="docs-heading-anchor-permalink" href="#SNaQ" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/JuliaPhylo/SNaQ.jl">SNaQ</a>.</p><ul><li><a href="#SNaQ.fAbs"><code>SNaQ.fAbs</code></a></li><li><a href="#SNaQ.DataCF"><code>SNaQ.DataCF</code></a></li><li><a href="#SNaQ.Quartet"><code>SNaQ.Quartet</code></a></li><li><a href="#SNaQ.QuartetNetwork"><code>SNaQ.QuartetNetwork</code></a></li><li><a href="#SNaQ.QuartetT"><code>SNaQ.QuartetT</code></a></li><li><a href="#SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.afterOptBL!</code></a></li><li><a href="#SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}"><code>SNaQ.afterOptBLAll!</code></a></li><li><a href="#SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}"><code>SNaQ.afterOptBLRepeat!</code></a></li><li><a href="#SNaQ.bootsnaq-Tuple{HybridNetwork, Union{DataFrames.DataFrame, Vector{Vector{HybridNetwork}}}}"><code>SNaQ.bootsnaq</code></a></li><li><a href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>SNaQ.calculateObsCFAll!</code></a></li><li><a href="#SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}"><code>SNaQ.checkMapDF</code></a></li><li><a href="#SNaQ.countquartetsintrees"><code>SNaQ.countquartetsintrees</code></a></li><li><a href="#SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}"><code>SNaQ.deleteLeaf!</code></a></li><li><a href="#SNaQ.fittedQuartetCF"><code>SNaQ.fittedQuartetCF</code></a></li><li><a href="#SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.gammaZero!</code></a></li><li><a href="#SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.getNeighborsTarget</code></a></li><li><a href="#SNaQ.hybridatnode-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode</code></a></li><li><a href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode!</code></a></li><li><a href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}"><code>SNaQ.hybridatnode!</code></a></li><li><a href="#SNaQ.mapAllelesCFtable-Tuple{AbstractString, AbstractString}"><code>SNaQ.mapAllelesCFtable</code></a></li><li><a href="#SNaQ.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}"><code>SNaQ.mapAllelesCFtable!</code></a></li><li><a href="#SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.moveHybrid!</code></a></li><li><a href="#SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.moveTargetUpdate!</code></a></li><li><a href="#SNaQ.nchoose1234-Tuple{Int64}"><code>SNaQ.nchoose1234</code></a></li><li><a href="#SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}"><code>SNaQ.optBL!</code></a></li><li><a href="#SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}"><code>SNaQ.optTopLevel!</code></a></li><li><a href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>SNaQ.optTopRun1!</code></a></li><li><a href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>SNaQ.optTopRuns!</code></a></li><li><a href="#SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}"><code>SNaQ.proposedTop!</code></a></li><li><a href="#SNaQ.quartetdata_columnnames-Union{Tuple{Type{T}}, Tuple{T}, Tuple{S}} where {S, T&lt;:StaticArraysCore.StaticArray{Tuple{3}, S, 1}}"><code>SNaQ.quartetdata_columnnames</code></a></li><li><a href="#SNaQ.quartetrank-Tuple{AbstractVector, Matrix}"><code>SNaQ.quartetrank</code></a></li><li><a href="#SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}"><code>SNaQ.readInputData</code></a></li><li><a href="#SNaQ.readInputTrees-Tuple{AbstractString}"><code>SNaQ.readInputTrees</code></a></li><li><a href="#SNaQ.readSnaqNetwork-Tuple{AbstractString}"><code>SNaQ.readSnaqNetwork</code></a></li><li><a href="#SNaQ.readTableCF-Tuple{AbstractString}"><code>SNaQ.readTableCF</code></a></li><li><a href="#SNaQ.readTableCF!-Tuple{DataCF, DataFrames.DataFrame, Vector{Int64}}"><code>SNaQ.readTableCF!</code></a></li><li><a href="#SNaQ.readTopologyLevel1-Tuple{AbstractString}"><code>SNaQ.readTopologyLevel1</code></a></li><li><a href="#SNaQ.readTrees2CF-Tuple{AbstractString}"><code>SNaQ.readTrees2CF</code></a></li><li><a href="#SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}"><code>SNaQ.sameTaxa</code></a></li><li><a href="#SNaQ.sampleCFfromCI"><code>SNaQ.sampleCFfromCI</code></a></li><li><a href="#SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.setGammaBLfromGammaz!</code></a></li><li><a href="#SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}"><code>SNaQ.setLength!</code></a></li><li><a href="#SNaQ.setNonIdBL!-Tuple{HybridNetwork}"><code>SNaQ.setNonIdBL!</code></a></li><li><a href="#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.snaq!</code></a></li><li><a href="#SNaQ.sort_stringasinteger!-Tuple{Any}"><code>SNaQ.sort_stringasinteger!</code></a></li><li><a href="#SNaQ.sorttaxa!-Tuple{DataCF}"><code>SNaQ.sorttaxa!</code></a></li><li><a href="#SNaQ.summarizeDataCF-Tuple{DataCF}"><code>SNaQ.summarizeDataCF</code></a></li><li><a href="#SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}"><code>SNaQ.taxadiff</code></a></li><li><a href="#SNaQ.topologyMaxQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.topologyMaxQPseudolik!</code></a></li><li><a href="#SNaQ.topologyQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.topologyQPseudolik!</code></a></li><li><a href="#SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}"><code>SNaQ.traverseContainRoot!</code></a></li><li><a href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>SNaQ.undirectedOtherNetworks</code></a></li><li><a href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.undoGammaz!</code></a></li><li><a href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.updateBL!</code></a></li><li><a href="#SNaQ.updateContainRoot!"><code>SNaQ.updateContainRoot!</code></a></li><li><a href="#SNaQ.writeTableCF-Tuple{Vector{Quartet}}"><code>SNaQ.writeTableCF</code></a></li><li><a href="#SNaQ.writeTableCF-Union{Tuple{Array{SNaQ.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{SNaQ.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>SNaQ.writeTableCF</code></a></li><li><a href="#SNaQ.writeTopologyLevel1-Tuple{HybridNetwork}"><code>SNaQ.writeTopologyLevel1</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.fAbs" href="#SNaQ.fAbs"><code>SNaQ.fAbs</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>default values for tolerance parameters, used in the optimization of branch lengths (fAbs, fRel, xAbs, xRel) and in the acceptance of topologies (likAbs, numFails).</p><p>if changes are made here, <strong>make the same</strong> in the docstring for snaq! below</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbs</th><th style="text-align: right">fRel</th><th style="text-align: right">xAbs</th><th style="text-align: right">xRel</th><th style="text-align: right">numFails</th><th style="text-align: right">likAbs</th><th style="text-align: right">multiplier</th></tr><tr><td style="text-align: right">v0.5.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-3</td><td style="text-align: right">1e-2</td><td style="text-align: right">75</td><td style="text-align: right">1e-6</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.3.0</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right">0.01</td><td style="text-align: right"></td></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-6</td><td style="text-align: right">1e-5</td><td style="text-align: right">1e-4</td><td style="text-align: right">1e-3</td><td style="text-align: right">100</td><td style="text-align: right"></td><td style="text-align: right">10000</td></tr><tr><td style="text-align: right">older</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>v0.5.1: based on Nan Ji&#39;s work. same xAbs and xRel as in phylonet (as of 2015). earlier: multiplier was used; later: likAbs = multiplier*fAbs) &quot;older&quot;: values from GLM.jl, Prof Bates</p><p>default values used on a single topology, to optimize branch lengths and gammas, at the very end of snaq!, and by topologyMaxQPseudolik! since v0.5.1.</p><table><tr><th style="text-align: right">version</th><th style="text-align: right">fAbsBL</th><th style="text-align: right">fRelBL</th><th style="text-align: right">xAbsBL</th><th style="text-align: right">xRelBL</th></tr><tr><td style="text-align: right">v0.0.1</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-12</td><td style="text-align: right">1e-10</td><td style="text-align: right">1e-10</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L8-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.DataCF" href="#SNaQ.DataCF"><code>SNaQ.DataCF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DataCF</code></pre><p>type that contains the following attributes:</p><ul><li>quartet (vector of Quartets)</li><li>numQuartets</li><li>tree (vector of trees: empty if a table of CF was input instead of list of trees)</li><li>numTrees (-1 if a table CF was input instead of list of trees)</li><li>repSpecies (taxon names that were repeated in table of CF or input gene trees: used inside snaq for multiple alleles case)</li></ul><p>The list of Quartet may be accessed with the attribute .quartet. If the input was a list of trees, the HybridNetwork&#39;s can be accessed with the attribute .tree. For example, if the DataCF object is named d, d.quartet[1] will show the first quartet and d.tree[1] will print the first input tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.Quartet" href="#SNaQ.Quartet"><code>SNaQ.Quartet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Quartet</code></pre><p>type that saves the information on a given 4-taxon subset. It contains the following attributes:</p><ul><li>number: integer</li><li>taxon: vector of taxon names, like t1 t2 t3 t4</li><li>obsCF: vector of observed CF, in order 12|34, 13|24, 14|23</li><li>logPseudoLik</li><li>ngenes: number of gene trees used to compute the observed CF; -1.0 if unknown</li><li>qnet: <a href="#SNaQ.QuartetNetwork"><code>QuartetNetwork</code></a>, which saves the expCF after snaq estimation to emphasize that the expCF depend on a specific network, not the data</li></ul><p>see also: <a href="#SNaQ.QuartetT"><code>QuartetT</code></a> for quartet with data of user-defined type <code>T</code>, using a mapping between quartet indices and quartet taxa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.QuartetNetwork" href="#SNaQ.QuartetNetwork"><code>SNaQ.QuartetNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuartetNetwork(net::HybridNetwork)</code></pre><p>Subtype of <code>Network</code> abstract type. A <code>QuartetNetwork</code> object is an internal type used to calculate the expected CFs of quartets on a given network. Attributes of the <code>QuartetNetwork</code> objects need not be updated at a given time (see below).</p><p>The procedure to calculate expected CFs for a given network is as follows:</p><ol><li>A <code>QuartetNetwork</code> object is created for each <code>Quartet</code> using <code>extractQuartet!(net,d)</code> for <code>net::HybridNetwork</code> and <code>d::DataCF</code></li><li>The vector <code>d.quartet</code> has all the <code>Quartet</code> objects, each with a <code>QuartetNetwork</code> object (<code>q.qnet</code>). Attibutes in <code>QuartetNetwork</code> are not updated at this point</li><li>Attributes in <code>QuartetNetwork</code> are partially updated when calculating the expected CF (<code>calculateExpCFAll!</code>). To calculate the expected CF for this quartet, we need to update the attributes: <code>which</code>, <code>typeHyb</code>, <code>t1</code>, <code>split</code>, <code>formula</code>, <code>expCF</code>. To do this, we need to modify the <code>QuartetNetwork</code> object (i.e. merge edges,...). But we do not want to modify it directly because it is connected to the original <code>net</code> via a map of the edges and nodes, so we use a deep copy: <code>qnet=deepcopy(q.qnet)</code> and then <code>calculateExpCFAll!(qnet)</code>. Attributes that are updated on the original <code>QuartetNetwork</code> object <code>q.qnet</code> are:<ul><li><code>q.qnet.hasEdge</code>: array of booleans of length equal to <code>net.edge</code> that shows which identifiable edges and gammas of <code>net</code> (<code>net.ht</code>) are in <code>qnet</code> (and still identifiable). Note that the first elements of the vector correspond to the gammas.</li><li><code>q.qnet.index</code>: length should match the number of trues in <code>qnet.hasEdge</code>. It has the indexes in <code>qnet.edge</code> from the edges in <code>qnet.hasEdge</code>. Note that the first elements of the vector correspond to the gammas.</li><li><code>q.qnet.edge</code>: list of edges in <code>QuartetNetwork</code>. Note that external edges in <code>net</code> are collapsed when they appear in <code>QuartetNetwork</code>, so only internal edges map directly to edges in <code>net</code></li><li><code>q.qnet.expCF</code>: expected CF for this <code>Quartet</code></li></ul></li></ol><p>Why not modify the original <code>QuartetNetwork</code>? We wanted to keep the original <code>QuartetNetwork</code> stored in <code>DataCF</code> with all the identifiable edges, to be able to determine if this object had been changed or not after a certain optimization.</p><p>The process is:</p><ol><li>Deep copy of full network to create <code>q.qnet</code> for <code>Quartet q</code>. This <code>QuartetNetwork</code> object has only 4 leaves now, but does not have merged edges (the identifiable ones) so that we can correspond to the edges in net. This <code>QuartetNetwork</code> does not have other attributes updated.</li><li>For the current set of branch lengths and gammas, we can update the attributes in <code>q.qnet</code> to compute the expected CF. The functions that do this will &quot;destroy&quot; the <code>QuartetNetwork</code> object by merging edges, removing nodes, etc... So, we do this process in <code>qnet=deepcopy(q.qnet)</code>, and at the end, only update <code>q.qnet.expCF</code>.</li><li>After we optimize branch lengths in the full network, we want to update the branch lengths in <code>q.qnet</code>. The edges need to be there (which is why we do not want to modify this <code>QuartetNetwork</code> object by merging edges), and we do not do a deep-copy of the full network again. We only change the values of branch lengths and gammas in <code>q.qnet</code>, and we can re-calculate the expCF by creating a deep copy <code>qnet=deepcopy(q.qnet)</code> and run the other functions (which merge edges, etc) to get the <code>expCF</code>.</li></ol><p>Future work: there are definitely more efficient ways to do this (without the deep copies). In addition, currently edges that are no longer identifiable in <code>QuartetNetwork</code> do not appear in <code>hasEdge</code> nor <code>index</code>. Need to study this.</p><pre><code class="language-julia-repl hljs">julia&gt; net0 = readTopology(&quot;(s17:13.76,(((s3:10.98,(s4:8.99,s5:8.99)I1:1.99)I2:0.47,(((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.72)I12:1.47)I13:1.48)I14:1.26,(((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.40,s22:2.40)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98)I22:1.05);&quot;);

julia&gt; net = readTopologyLevel1(writeTopology(net0)) ## need level1 attributes for functions below
HybridNetwork, Un-rooted Network
46 edges
46 nodes: 23 tips, 1 hybrid nodes, 22 internal tree nodes.
tip labels: s17, s3, s4, s5, ...
(s4:8.99,s5:8.99,(s3:10.0,((((s6:2.31,s7:2.31)I3:4.02,(s8:4.97,#H24:0.0::0.279)I4:1.36)I5:3.64,((s9:8.29,((s10:2.37,s11:2.37)I6:3.02,(s12:2.67,s13:2.67)I7:2.72)I8:2.89)I9:0.21,((s14:2.83,(s15:1.06,s16:1.06)I10:1.78)I11:2.14)#H24:3.52::0.721)I12:1.47)I13:1.48,((((s18:5.46,s19:5.46)I15:0.59,(s20:4.72,(s21:2.4,s22:2.4)I16:2.32)I17:1.32)I18:2.68,(s23:8.56,(s1:4.64,s2:4.64)I19:3.92)I20:0.16)I21:3.98,s17:10.0)I22:1.26)I14:0.47)I2:1.99)I1;

julia&gt; q1 = Quartet(1,[&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;],[0.296,0.306,0.398])
number: 1
taxon names: [&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;]
observed CF: [0.296, 0.306, 0.398]
pseudo-deviance under last used network: 0.0 (meaningless before estimation)
expected CF under last used network: Float64[] (meaningless before estimation)

julia&gt; qnet = SNaQ.extractQuartet!(net,q1)
taxa: [&quot;s1&quot;, &quot;s16&quot;, &quot;s18&quot;, &quot;s23&quot;]
number of hybrid nodes: 1

julia&gt; sum([e.istIdentifiable for e in net.edge]) ## 23 identifiable edges in net
23

julia&gt; idedges = [ee.number for ee in net.edge[[e.istIdentifiable for e in net.edge]]];

julia&gt; print(idedges)
[5, 6, 9, 11, 12, 13, 17, 20, 21, 22, 26, 27, 28, 29, 30, 31, 34, 38, 39, 40, 44, 45, 46]

julia&gt; length(qnet.hasEdge) ## 24 = 1 gamma + 23 identifiable edges
24

julia&gt; sum(qnet.hasEdge) ## 8 = 1 gamma + 7 identifiable edges in qnet
8

julia&gt; print(idedges[qnet.hasEdge[2:end]]) ## 7 id. edges: [12, 13, 29, 30, 31, 45, 46]
[12, 13, 29, 30, 31, 45, 46]

julia&gt; qnet.edge[qnet.index[1]].number ## 11 = minor hybrid edge
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L4-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.QuartetT" href="#SNaQ.QuartetT"><code>SNaQ.QuartetT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>QuartetT{T}</p><p>Generic type for 4-taxon sets. Fields:</p><ul><li><code>number</code>: rank of the 4-taxon set</li><li><code>taxonnumber</code>: static vector of 4 integers, assumed to be distinct and sorted</li><li><code>data</code>: object of type <code>T</code></li></ul><p>For easier look-up, a unique mapping is used between the rank (<code>number</code>) of a 4-taxon set and its 4 taxa (see <a href="#SNaQ.quartetrank-Tuple{AbstractVector, Matrix}"><code>quartetrank</code></a> and <a href="#SNaQ.nchoose1234-Tuple{Int64}"><code>nchoose1234</code></a>):</p><p>rank-1 = (t1-1) choose 1 + (t2-1) choose 2 + (t3-1) choose 3 + (t4-1) choose 4</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nCk = SNaQ.nchoose1234(5)
6×4 Matrix{Int64}:
 0   0   0  0
 1   0   0  0
 2   1   0  0
 3   3   1  0
 4   6   4  1
 5  10  10  5

julia&gt; SNaQ.QuartetT(1,3,4,6, [.92,.04,.04, 100], nCk)
4-taxon set number 8; taxon numbers: 1,3,4,6
data: [0.92, 0.04, 0.04, 100.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L171-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.afterOptBL!-Tuple{HybridNetwork, DataCF, Bool, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.afterOptBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>afterOptBL</code> road map</p><p>Function that will check if there are <code>h==0,1;t==0,hz==0,1</code> cases in a network after calling <code>optBL!</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will move origin/target, if false, add/delete N times before giving up (we have only tested <code>closeN=true</code>)</li><li><code>origin=true</code> will move origin, false will move target. We added this to avoid going back and forth between the same networks</li><li><code>movesgamma</code> vector of counts of number of times each move is proposed to fix a gamma zero problem: <code>(add,mvorigin,mvtarget,chdir,delete,nni)</code></li></ul><p>Procedure:</p><ul><li><p>First we split the <code>ht</code> vector in <code>nh,nt,nhz</code> (gammas, lengths, gammaz)</p></li><li><p>If we find a <code>h==0,1</code>, we loop through <code>nh</code> to find a hybrid edge with h==0 or 1 and want to try to fix this by doing:</p><ul><li><code>gammaZero!(currT,d,edge,closeN,origin,N,movesgamma)</code> which returns true if there was a successful change, and we stop the loop</li></ul></li><li><p>If we find a <code>t==0</code>, we loop through all <code>nt</code> to find such edge, and do NNI move on this edge; return true if change successful and we stop the loop</p></li><li><p>If we find a <code>hz==0,1</code>, we loop through <code>nhz</code> to find such hybrid edge and call <code>gammaZero</code> again</p></li><li><p>If we did a successful change, we run <code>optBL</code> again, and recheck if there are no more problems.</p></li><li><p>Returns successchange, flagh, flagt,flaghz (flag=true means no problems)</p></li><li><p>If it is the multiple alleles case, it will not try to fix <code>h==0,1;hz==0,1</code> because it can reach a case that violates the multiple alleles condition. If we add a check here, things become horribly slow and inefficient, so we just delete a hybridization that has <code>h==0,1;hz==0,1</code></p></li></ul><p>** Important: ** <code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L572-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}" href="#SNaQ.afterOptBLAll!-Tuple{HybridNetwork, DataCF, Integer, Bool, Float64, Float64, Bool, Vector{Int64}, Float64, Float64, Float64}"><code>SNaQ.afterOptBLAll!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>afterOptBLAll</code> road map</p><p>After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>. This function will try to fix the gamma zero problem, but if it cannot, it will call <code>moveDownLevel</code>, to delete the hybridization from the network.</p><p>Procedure:</p><p>While <code>startover=true</code> and <code>tries&lt;N</code></p><ul><li>While <code>badliks &lt; N2</code> (number of bad pseudolikelihoods are less than <code>N2</code>)<ul><li>Run <code>success = afterOptBLRepeat</code></li><li>If <code>success = true</code> (it changed something):<ul><li>If worse pseudolik, then go back to original topology <code>currT</code>, set <code>startover=true</code> and <code>badliks++</code></li><li>If better pseudolik, then check flags. If all good, then <code>startover=false</code>; otherwise <code>startover = true</code></li></ul></li><li>If <code>success = false</code> (nothing changed), then set <code>badliks=N2+1</code> (to end the while on <code>currT</code>)<ul><li>If all flags are ok, then <code>startover = false</code></li><li>If bad h or hz, then call <code>moveDownLevel</code> (delete one hybridization), and set <code>startover = true</code> (maybe deleting that hybridization did not fix other gamma zero problems)</li><li>If bad t, then set <code>startover = false</code></li></ul></li></ul></li><li>If left second while by back to original <code>currT</code>, and still bad h/hz, then move down one level, and <code>startover=true</code>; otherwise <code>startover=false</code></li></ul><p>If first while ends by <code>tries&gt;N</code>, then it checks one last time the flags, if bad h/hz will move down one level, and exit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L757-L776">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}" href="#SNaQ.afterOptBLRepeat!-Tuple{HybridNetwork, DataCF, Integer, Bool, Bool, Bool, Vector{Int64}}"><code>SNaQ.afterOptBLRepeat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>afterOptBLRepeat</code> road map</p><p><code>afterOptBL</code> is doing only one change, but we need to repeat multiple times to be sure that we fix all the gamma zero problems, which is why we call <code>afterOptBLRepeat</code>. This function will repeat <code>afterOptBL</code> every time a successful change happened; this is done only if <code>closeN=false</code>, because we would delete/add hybridizations and need to stop after tried N times. If <code>closeN=true</code> (default), then <code>afterOptBLRepeat</code> only does one <code>afterOptBL</code>, because in this case, only the neighbor edges need to be tested, and this would have been done already in <code>gammaZero</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L689-L695">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.bootsnaq-Tuple{HybridNetwork, Union{DataFrames.DataFrame, Vector{Vector{HybridNetwork}}}}" href="#SNaQ.bootsnaq-Tuple{HybridNetwork, Union{DataFrames.DataFrame, Vector{Vector{HybridNetwork}}}}"><code>SNaQ.bootsnaq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootsnaq(T::HybridNetwork, df::DataFrame)
bootsnaq(T::HybridNetwork, vector of tree lists)</code></pre><p>Bootstrap analysis for SNaQ. Bootstrap data can be quartet concordance factors (CF), drawn from sampling uniformly in their credibility intervals, as given in the data frame <code>df</code>. Alternatively, bootstrap data can be gene trees sampled from a vector of tree lists: one list of bootstrap trees per locus (see <code>readBootstrapTrees</code> to generate this, from a file containing a list of bootstrap files: one per locus).</p><p>From each bootstrap replicate, a network is estimated with snaq!, with a search starting from topology <code>T</code>. Optional arguments include the following, with default values in parentheses:</p><ul><li><code>hmax</code> (1): max number of reticulations in the estimated networks</li><li><code>nrep</code> (10): number of bootstrap replicates.</li><li><code>runs</code> (10): number of independent optimization runs for each replicate</li><li><code>filename</code> (&quot;bootsnaq&quot;): root name for output files. No output files if &quot;&quot;.</li><li><code>seed</code> (0 to get a random seed from the clock): seed for random number generator</li><li><code>otherNet</code> (empty): another starting topology so that each replicate will start prcnet% runs on otherNet and (1-prcnet)% runs on <code>T</code></li><li><code>prcnet</code> (0): percentage of runs starting on <code>otherNet</code>; error if different than 0.0, and otherNet not specified.</li><li><code>ftolRel</code>, <code>ftolAbs</code>, <code>xtolRel</code>, <code>xtolAbs</code>, <code>liktolAbs</code>, <code>Nfail</code>, <code>probST</code>, <code>verbose</code>, <code>outgroup</code>: see <code>snaq!</code>, same defaults.</li></ul><p>If <code>T</code> is a tree, its branch lengths are first optimized roughly with <a href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>updateBL!</code></a> (by using the average CF of all quartets defining each branch and calculating the coalescent units corresponding to this quartet CF). If <code>T</code> has one or more reticulations, its branch lengths are taken as is to start the search. The branch lengths of <code>otherNet</code> are always taken as is to start the search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/bootstrap.jl#L218-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}" href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>SNaQ.calculateObsCFAll!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculateObsCFAll!(DataCF, taxa::Union{Vector{&lt;:AbstractString}, Vector{Int}})</code></pre><p>Calculate observed concordance factors: update the <code>.quartet[i].obsCF</code> values of the <code>DataCF</code> object based on its .tree vector.</p><pre><code class="nohighlight hljs">calculateObsCFAll!(vector of quartets, vector of trees, taxa)</code></pre><p>Calculate observed concordance factors: update the <code>.obsCF</code> values of the quartets, based on the trees, and returns a new <code>DataCF</code> object with these updated quartets and trees.</p><pre><code class="nohighlight hljs">calculateObsCFAll_noDataCF!(vector of quartets, vector of trees, taxa)</code></pre><p>update the <code>.obsCF</code> values of the quartets based on the trees, but returns nothing.</p><p>Warning: all these functions need input trees (without any reticulations: h=0).</p><p>See also: <a href="#SNaQ.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a faster algorithm, processing each input tree only once. <code>calculateObsCFAll_noDataCF!</code> processes each input tree <code># quartet</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L509-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}" href="#SNaQ.checkMapDF-Tuple{DataFrames.DataFrame}"><code>SNaQ.checkMapDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkMapDF(mapping_allele2species::DataFrame)</code></pre><p>Check that the data frame has one column named &quot;allele&quot; or &quot;individual&quot;, and one column named &quot;species&quot;. Output: indices of these column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/multipleAlleles.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.countquartetsintrees" href="#SNaQ.countquartetsintrees"><code>SNaQ.countquartetsintrees</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">countquartetsintrees(trees [, taxonmap]; which=:all, weight_byallele=true)</code></pre><p>Calculate the quartet concordance factors (CF) observed in the <code>trees</code> vector. If present, <code>taxonmap</code> should be a dictionary that maps each allele name to it&#39;s species name. To save to a file, first convert to a data frame using <a href="#SNaQ.writeTableCF-Tuple{Vector{Quartet}}"><code>writeTableCF</code></a>. When <code>which=:all</code>, quartet CFs are calculated for all 4-taxon sets. (Other options are not implemented yet.)</p><p>The algorithm runs in O(mn⁴) where m is the number of trees and n is the number of tips in the trees.</p><p>CFs are calculated at the species level only, that is, considering 4-taxon sets made of 4 distinct species, even if the gene trees may have multiple alleles from the same species. For 4 distinct species <code>a,b,c,d</code>, all alleles from each species (<code>a</code> etc.) will be considered to calculate the quartet CF.</p><p>By default, each gene has a weight of 1. So if there are <code>n_a</code> alleles from <code>a</code>, <code>n_b</code> alleles from <code>b</code> etc. in a given gene, then each set of 4 alleles has a weight of <code>1/(n_a n_b b_c n_c)</code> in the calculation of the CF for <code>a,b,c,d</code>. With option <code>weight_byallele=true</code>, then each set of 4 alleles is given a weight of 1 instead. This inflates the total number of sets used to calculate the quartet CFs (to something larger than the number of genes). This may also affect the CF values if the number of alleles varies across genes: genes with more alleles will be given more weight.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tree1 = readTopology(&quot;(E,(A,B),(C,D),O);&quot;); tree2 = readTopology(&quot;(((A,B),(C,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2]);
Reading in trees, looking at 15 quartets in each...
0+--+100%
  **

julia&gt; t # taxon order: t[i] = name of taxon number i
6-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;C&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; length(q) # 15 four-taxon sets on 6 taxa
15

julia&gt; q[1] # both trees agree on AB|CD: resolution 1
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [1.0, 0.0, 0.0, 2.0]

julia&gt; q[8] # tree 2 is missing O (taxon 6), tree 1 wants resolution 3: AO|CD
4-taxon set number 8; taxon numbers: 1,3,4,6
data: [0.0, 0.0, 1.0, 1.0]

julia&gt; q[11] # tree 1 has ACEO unresolved, and tree 2 is missing O: no data for this quartet
4-taxon set number 11; taxon numbers: 1,3,5,6
data: [0.0, 0.0, 0.0, 0.0]

julia&gt; tree1 = readTopology(&quot;(E,(a1,B),(a2,D),O);&quot;); tree2 = readTopology(&quot;(((a1,a2),(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); showprogressbar=false);

julia&gt; t
5-element Vector{String}:
 &quot;A&quot;
 &quot;B&quot;
 &quot;D&quot;
 &quot;E&quot;
 &quot;O&quot;

julia&gt; q[1] # tree 1 has discordance: a1B|DE and a2D|BE. tree 2 has AE|BD for both alleles of A
4-taxon set number 1; taxon numbers: 1,2,3,4
data: [0.25, 0.25, 0.5, 2.0]

julia&gt; q[3] # tree 2 is missing O (taxon 5), and a2 is unresolved in tree 1. There&#39;s only a1B|EO
4-taxon set number 3; taxon numbers: 1,2,4,5
data: [1.0, 0.0, 0.0, 0.5]

julia&gt; df = writeTableCF(q,t); # to get a DataFrame that can be saved to a file later

julia&gt; show(df, allcols=true)
5×9 DataFrame
 Row │ qind   t1      t2      t3      t4      CF12_34  CF13_24  CF14_23  ngenes  
     │ Int64  String  String  String  String  Float64  Float64  Float64  Float64 
─────┼───────────────────────────────────────────────────────────────────────────
   1 │     1  A       B       D       E          0.25     0.25      0.5      2.0
   2 │     2  A       B       D       O          0.5      0.5       0.0      1.0
   3 │     3  A       B       E       O          1.0      0.0       0.0      0.5
   4 │     4  A       D       E       O          1.0      0.0       0.0      0.5
   5 │     5  B       D       E       O          0.0      0.0       0.0      0.0

julia&gt; # using CSV; CSV.write(df, &quot;filename.csv&quot;);

julia&gt; tree2 = readTopology(&quot;((A,(B,D)),E);&quot;);

julia&gt; q,t = countquartetsintrees([tree1, tree2], Dict(&quot;a1&quot;=&gt;&quot;A&quot;, &quot;a2&quot;=&gt;&quot;A&quot;); weight_byallele=true);
Reading in trees, looking at 5 quartets in each...
0+--+100%
  **

julia&gt; show(writeTableCF(q,t), allcols=true)
5×9 DataFrame
 Row │ qind   t1      t2      t3      t4      CF12_34   CF13_24   CF14_23   ngenes  
     │ Int64  String  String  String  String  Float64   Float64   Float64   Float64 
─────┼──────────────────────────────────────────────────────────────────────────────
   1 │     1  A       B       D       E       0.333333  0.333333  0.333333      3.0
   2 │     2  A       B       D       O       0.5       0.5       0.0           2.0
   3 │     3  A       B       E       O       1.0       0.0       0.0           1.0
   4 │     4  A       D       E       O       1.0       0.0       0.0           1.0
   5 │     5  B       D       E       O       0.0       0.0       0.0           0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L591-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}" href="#SNaQ.deleteLeaf!-Tuple{PhyloNetworks.Network, AbstractString}"><code>SNaQ.deleteLeaf!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>deleteLeaf!(net::HybridNetwork, leaf::AbstractString)</code> <code>deleteLeaf!(net::Network, leaf::Node)</code></p><p>Deletes the leaf taxon from the network. The leaf argument is the name of the taxon to delete.</p><p>Warnings:</p><ul><li>requires a level-1 network with up-to-date attributes for snaq! (e.g. non-missing branch lengths, gammaz, etc.)</li><li>does not care where the root is and does not update it to a sensible location if the root is affected by the leaf removal.</li><li>does not merge edges, i.e. does not remove all nodes of degree 2. Within snaq!, this is used to extract quartets and to keep track of which edge lengths in the original network map to the quartet network.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/pseudolik.jl#L349-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.fittedQuartetCF" href="#SNaQ.fittedQuartetCF"><code>SNaQ.fittedQuartetCF</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fittedQuartetCF(d::DataCF, format::Symbol)</code></pre><p>Data frame with the observed and expected quartet concordance factors after estimation of a network with <code>snaq!</code>, or fitting of quartet CF data on a fixed network. The format can be :wide (default) or :long.</p><ul><li>if wide, the output has one row per 4-taxon set, and each row has 10 columns: 4 columns for the taxon names, 3 columns for the observed CFs and 3 columns for the expected CF.</li><li>if long, the output has one row per quartet, i.e. 3 rows per 4-taxon sets, and 7 columns: 4 columns for the taxon names, one column to give the quartet resolution, one column for the observed CF and the last column for the expected CF.</li></ul><p>see also: <a href="#SNaQ.topologyQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>topologyQPseudolik!</code></a> and <a href="#SNaQ.topologyMaxQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>topologyMaxQPseudolik!</code></a> to update the fitted quartet CF expected under a specific network, inside the DataCF object <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/descriptive.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.gammaZero!-Tuple{HybridNetwork, DataCF, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.gammaZero!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>gammaZero</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>)</p><ol><li>First tries to do <code>changeDirection</code></li><li>If not successful from start, we call <code>moveHybrid</code></li><li>If successful move (change direction), we call <code>optBL</code> and check if we fixed the problem</li><li>If problem fixed and we do not have worse pseudolik, we return <code>success=true</code></li><li>If still problem or worse pseudolik, we call <code>moveHybrid</code></li></ol><p>** Important: ** Any function (<code>afterOptBL</code>) calling <code>gammaZero</code> is assuming that it only made a change, so if the returned value is true, then a change was made, and the other function needs to run <code>optBL</code> and check that all parameters are &#39;valid&#39;. If the returned value is false, then no change was possible and we need to remove a hybridization if the problem is h==0,1; hz==0,1. If the problem is t==0, we ignore this problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L517-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#SNaQ.getNeighborsTarget-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.getNeighborsTarget</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNeighborsTarget(hybrid_node, majoredge)</code></pre><p>Vector of edges that are incident to either:</p><ul><li>the node incident to <code>majoredge</code> other than <code>hybrid_node</code>, or</li><li>the tree child of <code>hybrid_node</code>.</li></ul><p>This vector of edges is used as the list of suitable neighbors of &quot;othermin&quot; to move the target of a hybrid edge, in <code>moveTargetUpdateRepeat!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/moves_snaq.jl#L691-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}" href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridatnode!(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Change the direction and status of edges in network <code>net</code>, to move the hybrid node in a cycle to the node with number <code>nodeNumber</code>. This node must be in one (and only one) cycle, otherwise an error will be thrown. Check and update the nodes&#39; field <code>inCycle</code>.</p><p>Output: <code>net</code> after hybrid modification.</p><p>Assumption: <code>net</code> must be of level 1, that is, each blob has a single cycle with a single reticulation.</p><p><strong>example</strong></p><pre><code class="language-julia hljs">net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
using PhyloPlots
plot(net, shownodenumber=true); # to locate nodes and their numbers. D of hybrid origin
hybridatnode!(net, -4)
plot(net, shownodenumber=true); # hybrid direction reversed: now 2B of hybrid origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/manipulateNet.jl#L96-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}" href="#SNaQ.hybridatnode!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}"><code>SNaQ.hybridatnode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridatnode!(net::HybridNetwork, hybrid::Node, newNode::Node)</code></pre><p>Move the reticulation from <code>hybrid</code> to <code>newNode</code>, which must in the same cycle. <code>net</code> is assumed to be of level 1, but <strong>no checks</strong> are made and fields are supposed up-to-date.</p><p>Called by <code>hybridatnode!(net, nodenumber)</code>, which is itself called by <a href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>undirectedOtherNetworks</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/manipulateNet.jl#L144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.hybridatnode-Tuple{HybridNetwork, Integer}" href="#SNaQ.hybridatnode-Tuple{HybridNetwork, Integer}"><code>SNaQ.hybridatnode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hybridatnode(net::HybridNetwork, nodeNumber::Integer)</code></pre><p>Move the hybrid node in a cycle to make node number <code>nodeNumber</code> a hybrid node Compared to [<code>hybridatnode!</code>], this method checks that <code>net</code> is of level 1 (required) and does not modify it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/manipulateNet.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}" href="#SNaQ.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}"><code>SNaQ.mapAllelesCFtable!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapAllelesCFtable!(quartet CF DataFrame, mapping DataFrame, columns, write?, filename)</code></pre><p>Modify (and return) the quartet concordance factor (CF) DataFrame: replace each allele name by the species name that the allele maps onto based on the mapping data frame. This mapping data frame should have columns named &quot;allele&quot; and &quot;species&quot; (see <code>rename!</code> to change column names if need be).</p><p>If <code>write?</code> is <code>true</code>, the modified data frame is written to a file named &quot;filename&quot;.</p><p>Warning: <a href="#SNaQ.mapAllelesCFtable-Tuple{AbstractString, AbstractString}"><code>mapAllelesCFtable</code></a> takes the quartet data file as its second argument, while <code>mapAllelesCFtable!</code> takes the quartet data (which it modifies) as its first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/multipleAlleles.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.mapAllelesCFtable-Tuple{AbstractString, AbstractString}" href="#SNaQ.mapAllelesCFtable-Tuple{AbstractString, AbstractString}"><code>SNaQ.mapAllelesCFtable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapAllelesCFtable(mapping file, CF file; filename, columns, delim)</code></pre><p>Create a new DataFrame containing the same concordance factors as in the input CF file, but with modified taxon names. Each allele name in the input CF table is replaced by the species name that the allele maps onto, based on the mapping file. The mapping file should have column names: allele and species.</p><p>Optional arguments:</p><ul><li>file name to write/save resulting CF table. If not specified, then the output data frame is not saved to a file.</li><li>column numbers for the taxon names. 1-4 by default.</li><li>any keyword arguments that <code>CSV.File</code> would accept. For example, delim=&#39;,&#39; by default: columns are delimited by commas. Unless specified otherwise by the user, <code>pool</code>=false (to read taxon names as Strings, not levels of a categorical factor, for combining the 4 columns with taxon names more easily). The same CSV arguments are used to read both input file (mapping file and quartet file)</li></ul><p>See also <a href="#SNaQ.mapAllelesCFtable!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Vector{Int64}, Bool, AbstractString}"><code>mapAllelesCFtable!</code></a> to input DataFrames instead of file names.</p><p>If a <code>filename</code> is specified, such as &quot;quartetCF_speciesNames.csv&quot; in the example below, this file is best read later with the option <code>pool=false</code>. example:</p><pre><code class="language-julia hljs">mapAllelesCFtable(&quot;allele-species-map.csv&quot;, &quot;allele-quartet-CF.csv&quot;;
                  filename = &quot;quartetCF_speciesNames.csv&quot;)
df_sp = CSV.read(&quot;quartetCF_speciesNames.csv&quot;, DataFrame); # DataFrame object
dataCF_specieslevel = readTableCF!(df_sp, mergerows=true); # DataCF object</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/multipleAlleles.jl#L8-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}" href="#SNaQ.moveHybrid!-Tuple{HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Bool, Bool, Integer, Vector{Int64}}"><code>SNaQ.moveHybrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>moveHybrid</code> road map</p><p>Function that tries to fix a gamma zero problem (<code>h==0,1; t==0; hz==0,1</code>) after changing direction of hybrid edge failed. This function is called in <code>gammaZero</code>.</p><p>Arguments:</p><ul><li><code>closeN=true</code> will try move origin/target on all neighbors (first choose minor/major edge at random, then make list of all neighbor edges and tries to put the hybrid node in all the neighbors until successful move); if false, will delete and add hybrid until successful move up to N times (this is never tested)</li></ul><p>Returns true if change was successful (not testing <code>optBL</code> again), and false if we could not move anything</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L472-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}" href="#SNaQ.moveTargetUpdate!-Tuple{HybridNetwork, PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}"><code>SNaQ.moveTargetUpdate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moveTargetUpdate!(net, hybrid_node, majoredge, newedge)</code></pre><p>Modify a level-1 network <code>net</code> by moving <code>majoredge</code>, which should be a hybrid edge parent of <code>hybrid_node</code>. Within SNaQ, <code>majoredge</code> is chosen by <code>chooseMinorMajor</code>.</p><ul><li>calls <code>moveTarget!(net,hybrid_node, majoredge, treeedge_belowhybrid, newedge)</code>, which does the move but does not update any attributes</li><li>updates all level-1 attributes needed for SNaQ: gammaz, containRoot</li><li>un-does the move and updates if the move is invalid, through another call to <code>moveTarget!</code> but with the &quot;undo&quot; option.</li></ul><p><code>newedge</code> should be a tree edge (enforced by <code>chooseEdgeOriginTarget!</code>) adjacent to the parent node of <code>majoredge</code> or to the tree child of <code>hybrid_node</code> (enforced by <code>getNeighborsTarget</code>)</p><p>Output: tuple of 3 booleans <code>(success, flag_triangle, flag_root)</code>.</p><ul><li><code>success</code> is false if the move failed (lead to an invalid network for SNaQ)</li><li><code>flag_triangle</code> is false if <code>net.hasVeryBadTriangle</code></li><li><code>flag_root</code> is false if the set of edges to place the root is empty</li></ul><p>If <code>success</code> is false, then the flags are not meant to be used downstream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/moves_snaq.jl#L1020-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.nchoose1234-Tuple{Int64}" href="#SNaQ.nchoose1234-Tuple{Int64}"><code>SNaQ.nchoose1234</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nchoose1234(nmax)</code></pre><p><code>nmax+1 x 4</code> matrix containing the binomial coefficient &quot;n choose k&quot; in row <code>n+1</code> and column <code>k</code>. In other words, <code>M[i,k]</code> gives &quot;i-1 choose k&quot;. It is useful to store these values and look them up to rank (a large number of) 4-taxon sets: see <a href="#SNaQ.quartetrank-Tuple{AbstractVector, Matrix}"><code>quartetrank</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L257-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}" href="#SNaQ.optBL!-Tuple{HybridNetwork, DataCF, Bool, Vararg{Float64, 4}}"><code>SNaQ.optBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>optBL</code> road map</p><p>Function that optimizes the numerical parameters (branch lengths and inheritance probabilities) for a given network. This function is called multiple times inside <code>optTopLevel!</code>.</p><ul><li>Input: network <code>net</code>, data <code>d</code></li><li>Numerical tolerances: <code>ftolAbs, ftolRel, xtolAbs, xtolRel</code></li><li>Function based on <code>MixedModels</code> <code>fit</code> function</li><li>The function assumes <code>net</code> has all the right attributes, and cannot check this inside because it would be inefficient</li></ul><p>Procedure:</p><ul><li><code>ht = parameters!(net)</code> extracts the vector of parameters to estimate <code>(h,t,gammaz)</code>, and sets as <code>net.ht</code>; identifies a bad diamond I, sets <code>net.numht</code> (vector of hybrid node numbers for h, edge numbers for t, hybrid node numbers for gammaz), and <code>net.index</code> to keep track of the vector of parameters to estimate</li><li><code>extractQuartet!(net,d)</code> does the following for all quartets in <code>d.quartet</code>:<ul><li>Extract quartet by deleting all leaves not in q -&gt; create <code>QuartetNetwork</code> object saved in <code>q.qnet</code></li><li>This network is ugly and does not have edges collapsed. This is done to keep a one-to-one correspondence between the edges in <code>q.qnet</code> and the edges in <code>net</code> (if we remove nodes with only two edges, we will lose this correspondence)</li><li>Calculate expected CF with <code>calculateExpCFAll</code> for a copy of <code>q.qnet</code>. We do this copy because we want to keep <code>q.qnet</code> as it is (without collapsed edges into one). The function will then save the <code>expCF</code> in <code>q.qnet.expCF</code></li></ul></li><li><code>calculateExpCFAll!(qnet)</code> will<ul><li>identify the type of quartet as type 1 (equivalent to a tree) or type 2 (minor CF different). Here the code will first clean up any hybrid node by removing nodes with only two edges before identifying the <code>qnet</code> (because identification depends on neighbor nodes to hybrid node); later, set <code>qnet.which</code> (1 or 2), <code>node.prev</code> (neighbor node to hybrid node), updates <code>node.k</code> (number of nodes in hybridization cycle, this can change after deleting the nodes with only two edges), <code>node.typeHyb</code> (1,2,3,4,5 depending on the number of nodes in the hybridization cycle and the origin/target of the minor hybrid edge; this attribute is never used).</li><li>eliminate hybridization: this will remove type 1 hybridizations first. If <code>qnet.which=1</code>, then the <code>qnet</code> is similar to a tree quartet, so it will calculate the internal length of the tree quartet: <code>qnet.t1</code>.</li><li>update split for <code>qnet.which=1</code>, to determine which taxa are together. For example, for the quartet 12|34, the split is [1,1,2,2] or [2,2,1,1], that is, taxon 1 and 2 are on the same side of the split. This will update <code>qnet.split</code></li><li>update formula for <code>qnet.which=1</code> to know the order of minorCF and majorCF in the vector <code>qnet.expCF</code>. That is, if the quartet is 1342 (order in <code>qnet.quartet.taxon</code>), then the expected CF should match the observed CF in 13|42, 14|32, 12|34 and the <code>qnet</code> is 12|34 (given by <code>qnet.split</code>), <code>qnet.formula</code> will be [2,2,1] minor, minor, major</li><li><code>calculateExpCF!(qnet)</code> for <code>qnet.which=1</code>, it will do <code>1-2/3exp(-qnet.t1)</code> if <code>qnet.formula[i]==1</code>, and <code>1/3exp(qnet.t1)</code> if <code>qnet.formula[i]==2</code>. For <code>qnet.which=2</code>, we need to make sure that there is only one hybrid node, and compute the major, minor1,minor2 expected CF in the order 12|34, 13|24, 14|23 of the taxa in <code>qnet.quartet.taxon</code></li></ul></li></ul><p>Then we create a <code>NLopt</code> object with algorithm BOBYQA and k parameters (length of ht). We define upper and lower bounds and define the objective function that should only depend on <code>x=(h,t,gz)</code> and g (gradient, which we do not have, but still need to put as argument).</p><p>The objective function <code>obj(x,g)</code> calls</p><ul><li><code>calculateExpCFAll!(d,x,net)</code> needs to be run after <code>extractQuartet(net,d)</code> that will update <code>q.qnet</code> for all quartet.  Assumes that <code>qnet.indexht</code> is updated already: we only need to do this at the beginning of <code>optBL!</code> because the topology is fixed at this point)<ul><li>First it will update the edge lengths according to x</li><li>If the <code>q.qnet.changed=true</code> (that is, any of <code>qnet</code> branches changed value), we need to call <code>calculateExpCFAll!(qnet)</code> on a copy of <code>q.qnet</code> (again because we want to leave <code>q.qnet</code> with the edge correspondence to <code>net</code>)</li></ul></li><li><code>update!(net,x)</code> simply saves the new x in <code>net.ht</code></li></ul><p>Finally, we call <code>NLopt.optimize</code>, and we update the <code>net.loglik</code> and <code>net.ht</code> at the end. After <code>optBL</code>, we want to call <code>afterOptBLAll</code> (or <code>afterOptBLAllMultipleAlleles</code>) to check if there are <code>h==0,1</code>; <code>t==0</code>; <code>hz==0,1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L297-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}" href="#SNaQ.optTopLevel!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, IO, Bool}"><code>SNaQ.optTopLevel!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>optTopLevel</code> road map</p><p>Function that does most of the heavy-lifting of <code>snaq</code>. It optimizes the pseudolikelihood for a given starting topology, and returns the best network. Assumes that the starting topology is level-1 network, and has all the attributes correctly updated.</p><p>Input parameters:</p><ul><li>Starting topology <code>currT</code>, input data <code>DataCF</code> <code>d</code>, maximum number of hybridizations <code>hmax</code></li><li>Numerical optimization parameters: <code>liktolAbs, Nfail, ftolRel, ftolAbs, xtolRel, xtolAbs</code></li><li>Print parameters: <code>verbose, logfile, writelog</code></li><li>Parameters to tune the search in space of networks: <code>closeN=true</code> only propose move origin/target to neighbor edges (coded, but not tested with <code>closeN=false</code>), <code>Nmov0</code> vector with maximum number of trials allowed per type of move <code>(add, mvorigin, mvtarget, chdir, delete, nni)</code>, by default computed inside with coupon’s collector formulas</li></ul><p>The optimization procedure keeps track of</p><ul><li><code>movescount</code>: count of proposed moves,</li><li><code>movesgamma</code>: count of proposed moves to fix a gamma zero situation (see below for definition of this situation),</li><li><code>movesfail</code>: count of failed moves by violation of level-1 network (<code>inCycle</code> attribute) or worse pseudolikelihood than current,</li><li><code>failures</code>: number of failed proposals that had a worse pseudolikelihood</li></ul><p>Optimization procedure:</p><p>While the difference between current loglik and proposed loglik is greater than <code>liktolAbs</code>, or <code>failures&lt;Nfail</code>, or <code>stillmoves=true</code>:</p><ul><li><p><code>Nmov</code> is updated based on <code>newT</code>. The type of move proposed will depend on <code>newT</code> (which is the same as <code>currT</code> at this point). For example, if <code>currT</code> is a tree, we cannot propose move origin/target.</p></li><li><p><code>move = whichMove</code> selects randomly a type of move, depending on <code>Nmov,movesfail,hmax,newT</code> with weights 1/5 by default for all, and 0 for delete. These weights are adjusted depending on <code>newT.numHybrids</code> and <code>hmax</code>. If <code>newT.numHybrids</code> is far from <code>hmax</code>, we give higher probability to adding a new hybrid (we want to reach the <code>hmax</code> sooner, maybe not the best strategy, easy to change).  Later, we adjust the weights by <code>movesfail</code> (first, give weight of 0 if <code>movesfail[i]&gt;Nmov[i]</code>, that is, if we reached the maximum possible number of moves allowed for a certain type) and then increase the probability of the other moves.  So, unless one move has <code>w=0</code>, nothing changes. This could be improved by using the outlier quartets to guide the proposal of moves.</p></li><li><p><code>whichMove</code> will choose a move randomly from the weights, it will return <code>none</code> if no more moves allowed, in which case, the optimization ends</p></li><li><p><code>flag=proposedTop!(move, newT)</code> will modify <code>newT</code> based on <code>move</code>. The function <code>proposedTop</code> will return <code>flag=true</code> if the move was successful (the move succeeded by <code>inCycle</code>, <code>containRoot</code>, available edge to make the move (more details in <code>proposedTop</code>)). If <code>flag=false</code>, then <code>newT</code> is cleaned, except for the case of multiple alleles. The function <code>proposedTop</code> keeps count of <code>movescount</code> (successful move), <code>movesfail</code> (unsuccessful move),</p><p>Options:</p><p><code>random=true</code>: moves major/minor hybrid edge with prob h,1-h, respectively</p><p><code>N=10</code>: number of trials for NNI edge.</p></li><li><p>if(flag) Optimize branch lengths with <code>optBL</code></p><p>If <code>newT.loglik</code> is better than <code>currT.loglik</code> by <code>liktolAbs</code>, jump to <code>newT</code> (<code>accepted=true</code>) and fix <code>gamma=0, t=0</code> problems (more info on <code>afterOptBL</code>)</p><p>If(accepted)   <code>failures=0</code>, <code>movesfail=zeros</code>, <code>movescount</code> for successful move +1</p></li></ul><p>end while</p><p>After choosing the best network <code>newT</code>, we do one last more thorough optimization of branch lengths with <code>optBL</code>, we change non identifiable branch lengths to -1 (only in debug mode) and return <code>newT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L1148-L1203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}" href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>SNaQ.optTopRun1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optTopRun1!(net, liktolAbs, Nfail, d::DataCF, hmax, etc.)</code></pre><p>The function will run 1 run by modifying the starting topology and calling <code>optTopLevel</code>. See <a href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>optTopRuns!</code></a> for a roadmap.</p><p><code>probST</code> (default in snaq is 0.3) is the probability of starting one run at the same input tree. So, with probability <code>1-probST</code>, we will change the topology by a NNI move on a tree edge without neighbor hybrid. If the starting topology is a network, then with probability <code>1-probST</code> it will also modify one randomly chosen hybrid edge: with prob 0.5, the function will move origin, with prob 0.5 will do move target.</p><p>If there are multiple alleles (<code>d.repSpecies</code> not empty), then the function has to check that the starting topology does not violate the multiple alleles condition.</p><p>After modifying the starting topology with NNI and/or move origin/target, <code>optTopLevel</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L1713-L1732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}" href="#SNaQ.optTopRuns!-Tuple{HybridNetwork, Float64, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, AbstractString, AbstractString, Integer, Float64}"><code>SNaQ.optTopRuns!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Road map for various functions behind <a href="#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a></p><pre><code class="nohighlight hljs">snaq!
optTopRuns!
optTopRun1!
optTopLevel!
optBL!</code></pre><p>All return their optimized network.</p><ul><li><a href="#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>snaq!</code></a> calls <code>optTopRuns!</code> once, after a deep copy of the starting network. If the data contain multiple alleles from a given species, <code>snaq!</code> first expands the leaf for that species into 2 separate leaves, and merges them back into a single leaf after calling <code>optTopRuns!</code>.</li><li><code>optTopRuns!</code> calls <a href="#SNaQ.optTopRun1!-Tuple{HybridNetwork, Any, Integer, DataCF, Integer, Float64, Float64, Float64, Float64, Bool, Bool, Vector{Int64}, Integer, IO, Bool, Float64}"><code>optTopRun1!</code></a> several (<code>nrun</code>) times. assumes level-1 network with &gt;0 branch lengths. assumes same tips in network as in data: i.e. 2 separate tips per species                                          that has multiple alleles. each call to <code>optTopRun1!</code> gets the same starting network.</li><li><code>optTopRun1!</code> calls <code>optTopLevel!</code> once, after deep copying + changing the starting network slightly.</li><li><code>optTopLevel!</code> calls <code>optBL!</code> various times and proposes new network with various moves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L1481-L1504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}" href="#SNaQ.proposedTop!-Tuple{Integer, HybridNetwork, Bool, Integer, Integer, Vector{Int64}, Vector{Int64}, Bool}"><code>SNaQ.proposedTop!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>proposedTop!(move,newT,random,count,N,movescount,movesfail,multall)</code> road map</p><p>Function to change the current network <code>newT</code> by a given <code>move</code>, and checks that the move was successful (correct attributes). If not successful, <code>newT</code> is changed back to its original state, except for the case of multiple alleles.</p><p><strong>Note</strong> that the update of attributes by each move is not done in all the network, but only in the local edges that were changed by the move. This is efficient (and makes a move easy to undo), but makes the code of each move function very clunky.</p><p>Arguments:</p><ul><li>move chosen from <code>whichMove</code> as described in <code>optTopLevel</code></li><li><code>newT</code> is the topology that will be modified inside with the move</li><li><code>random=true</code>: chooses minor hybrid edge with prob 1-h, and major edge with prob h, if false, always chooses minor hybrid edge</li><li><code>count</code>: simply which likelihood step we are in in the optimization at <code>optTopLevel</code></li><li><code>movescount</code> and <code>movesfail</code>: vector of counts of number of moves proposed</li><li><code>multall=true</code> if multiple alleles case: we need to check if the move did not violate the multiple alleles condition (sister alleles together and no gene flow into the alleles). This is inefficient because we are proposing moves that we can reject later, instead of being smart about the moves we propose: for example, move origin/target could rule out some neighbors that move gene flow into the alleles, the same for add hybridization; nni move can check if it is trying to separate the alleles)</li></ul><p>Moves:</p><ul><li><code>addHybridizationUpdate(newT,N)</code>:</li></ul><p>will choose a partition first (to avoid choosing edges that will create a non level-1 network) will choose two edges from this partition randomly, will not allow two edges in a cherry (non-identifiable), or sister edges that are not identifiable (the blacklist was a way to keep track of &quot;bad edges&quot; were we should not waste time trying to put hybridizations, it has never been used nor tested). Also choose gamma from U(0,0.5). The &quot;Update&quot; in the function name means that it creates the new hybrid, and also updates all the attributes of <code>newT</code></p><ul><li><code>node = chooseHybrid(newT)</code> choose a hybrid randomly for the next moves:</li><li><code>moveOriginUpdateRepeat!(newT,node,random)</code></li></ul><p>will choose randomly the minor/major hybrid edge to move (if <code>random=true</code>); will get the list of all neighbor edges where to move the origin, will move the origin and update all the attributes and check if the move was successful (not conflicting attributes); if not, will undo the move, and try with a different neighbor until it runs out of neighbors. Return true if the move was successful.</p><ul><li><code>moveTargetUpdateRepeat!(newT,node,random)</code></li></ul><p>same as move origin but moving the target</p><ul><li><code>changeDirectionUpdate!(newT,node,random)</code></li></ul><p>chooses minor/major hybrid edge at random (if `random=true), and changes the direction, and updates all the attributes. Checks if the move was successful (returns true), or undoes the change and returns false.</p><ul><li><code>deleteHybridizationUpdate!(newT,node)</code></li></ul><p>removes the hybrid node, updates the attributes, no need to check any attributes, always successful move</p><ul><li>NNIRepeat!(newT,N)</li></ul><p>choose an edge for nni that does not have a neighbor hybrid. It will try to find such an edge N times, and if it fails, it will return false (unsuccessful move). N=10 by default. If N=1, it rarely finds such an edge if the network is small or complex. The function cannot choose an external edge. it will update locally the attributes.</p><p>** Important: ** All the moves undo what they did if the move was not successful, so at the end you either have a <code>newT</code> with a new move and with all good attributes, or the same <code>newT</code> that started. This is important to avoid having to do deepcopy of the network before doing the move. Also, after each move, when we update the attributes, we do not update the attributes of the whole network, we only update the attributes of the edges that were affected by the move. This saves time, but makes the code quite clunky. Only the case of multiple alleles the moves does not undo what it did, because it finds out that it failed after the function is over, so just need to treat this case special.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L1026-L1068">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.quartetdata_columnnames-Union{Tuple{Type{T}}, Tuple{T}, Tuple{S}} where {S, T&lt;:StaticArraysCore.StaticArray{Tuple{3}, S, 1}}" href="#SNaQ.quartetdata_columnnames-Union{Tuple{Type{T}}, Tuple{T}, Tuple{S}} where {S, T&lt;:StaticArraysCore.StaticArray{Tuple{3}, S, 1}}"><code>SNaQ.quartetdata_columnnames</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quartetdata_columnnames(T) where T &lt;: StaticArray</code></pre><p>Vector of column names to hold the quartet data of type <code>T</code> in a data frame. If T is a length-3 vector type, they are &quot;CF12<em>34&quot;,&quot;CF13</em>24&quot;,&quot;CF14<em>23&quot;. If T is a length-4 vector type, the 4th name is &quot;ngenes&quot;. If T is a 3×n matrix type, the output vector contains 3×n names, 3 for each of &quot;CF&quot;, &quot;V2</em>&quot;, &quot;V3<em>&quot;, ... &quot;Vn</em>&quot;.</p><p>Used by <a href="#SNaQ.writeTableCF-Tuple{Vector{Quartet}}"><code>writeTableCF</code></a> to build a data frame from a vector of <a href="#SNaQ.QuartetT"><code>QuartetT</code></a> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.quartetrank-Tuple{AbstractVector, Matrix}" href="#SNaQ.quartetrank-Tuple{AbstractVector, Matrix}"><code>SNaQ.quartetrank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quartetrank(t1,t2,t3,t4, nCk::Matrix)
quartetrank([t1,t2,t3,t4], nCk)</code></pre><p>Return the rank of a four-taxon set with taxon numbers <code>t1,t2,t3,t4</code>, assuming that <code>ti</code>s are positive integers such that t1&lt;t2, t2&lt;t3 and t3&lt;t4 (assumptions not checked!). <code>nCk</code> should be a matrix of &quot;n choose k&quot; binomial coefficients: see <a href="#SNaQ.nchoose1234-Tuple{Int64}"><code>nchoose1234</code></a>.</p><p><strong>examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nCk = SNaQ.nchoose1234(5)
6×4 Matrix{Int64}:
 0   0   0  0
 1   0   0  0
 2   1   0  0
 3   3   1  0
 4   6   4  1
 5  10  10  5

julia&gt; SNaQ.quartetrank([1,2,3,4], nCk)
1

julia&gt; SNaQ.quartetrank([3,4,5,6], nCk)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/types.jl#L220-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}" href="#SNaQ.readInputData-Tuple{AbstractString, AbstractString, Symbol, Integer, Bool, AbstractString, Bool, Bool}"><code>SNaQ.readInputData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readInputData(trees, quartetfile, whichQuartets, numQuartets, writetable, tablename, writeQfile, writesummary)
readInputData(trees, whichQuartets, numQuartets, taxonlist,   writetable, tablename, writeQfile, writesummary)</code></pre><p>Read gene trees and calculate the observed quartet concordance factors (CF), that is, the proportion of genes (and the number of genes) that display each quartet for a given list of four-taxon sets.</p><p>Input:</p><ul><li><code>trees</code>: name of a file containing a list of input gene trees, or vector of trees (<code>HybridNetwork</code> objects)</li></ul><p>Optional arguments (defaults):</p><ul><li><code>quartetfile</code>: name of a file containing a list of quartets, or more precisely, a list of four-taxon sets</li><li><code>whichQuartets</code> (<code>:all</code>): which quartets to sample. <code>:all</code> for all of them, <code>:rand</code> for a random sample.</li><li><code>numQuartets</code>: number of quartets in the sample. default: total number of quartets if <code>whichQuartets=:all</code> and 10% of total if <code>whichQuartets=:rand</code></li><li><code>taxonlist</code> (all in the input gene trees): If <code>taxonlist</code> is used, <code>whichQuartets</code> will consist of <em>all</em> sets of 4 taxa in the <code>taxonlist</code>. </li><li><code>writetable</code> (true): write the table of observed CF?</li><li><code>tablename</code> (&quot;tableCF.txt&quot;): if <code>writetable</code> is true, the table of observed CFs is write to file <code>tablename</code></li><li><code>writeQfile</code> (false): write intermediate file with sampled quartets?</li><li><code>writesummary</code> (true): write a summary file? if so, the summary will go in file &quot;summaryTreesQuartets.txt&quot;.</li></ul><p>Uses <a href="#SNaQ.calculateObsCFAll!-Tuple{DataCF, Union{Vector{Int64}, Vector{&lt;:AbstractString}}}"><code>calculateObsCFAll!</code></a>, which implements a slow algorithm.</p><p>See also: <a href="#SNaQ.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a much faster algorithm; <a href="#SNaQ.readTrees2CF-Tuple{AbstractString}"><code>readTrees2CF</code></a>, which is basically a re-naming of <code>readInputData</code>, and <a href="#SNaQ.readTableCF-Tuple{AbstractString}"><code>readTableCF</code></a> to read a table of quartet CFs directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L861-L897">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readInputTrees-Tuple{AbstractString}" href="#SNaQ.readInputTrees-Tuple{AbstractString}"><code>SNaQ.readInputTrees</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readInputTrees(file)</code></pre><p>Read a text file with a list of trees/networks in parenthetical format (one tree per line) and transform them like <a href="#SNaQ.readTopologyLevel1-Tuple{AbstractString}"><code>readTopologyLevel1</code></a> does: to be unrooted, with resolved polytomies, missing branch lengths set to 1.0, etc. See <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/public/#PhyloNetworks.readMultiTopology"><code>PhyloNetworks.readMultiTopology</code></a> to read multiple trees or networks with no modification.</p><p>Output: array of HybridNetwork objects.</p><p>Each line starting with &quot;(&quot; will be considered as describing one topology. The file can have extra lines that are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L274-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readSnaqNetwork-Tuple{AbstractString}" href="#SNaQ.readSnaqNetwork-Tuple{AbstractString}"><code>SNaQ.readSnaqNetwork</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readSnaqNetwork(output file)</code></pre><p>Read the estimated network from a <code>.out</code> file generated by <code>snaq!</code>. The network score is read also, and stored in the network&#39;s field <code>.loglik</code>.</p><p>Warning: despite the name &quot;loglik&quot;, this score is only proportional to the network&#39;s pseudo-deviance: the lower, the better. Do NOT use this score to calculate an AIC or BIC (etc.) value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readwrite.jl#L422-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readTableCF!-Tuple{DataCF, DataFrames.DataFrame, Vector{Int64}}" href="#SNaQ.readTableCF!-Tuple{DataCF, DataFrames.DataFrame, Vector{Int64}}"><code>SNaQ.readTableCF!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readTableCF!(data frame, columns; mergerows=false)</code></pre><p>Read in quartet CFs from data frame, assuming information is in columns numbered <code>columns</code>, of length <strong>7 or 8</strong>: 4 taxon labels then 3 CFs then ngenes possibly.</p><p>If some species appears more than once in the same 4-taxon set (e.g. t1,t1,t2,t3), then the data frame is modified to remove rows (4-taxon sets) that are uninformative about between-species relationships. This situation may occur if multiple individuals are sampled from the same species. A 4-taxon set is uninformative (and its row is removed) if one taxon is repeated 3 or 4 times (like t1,t1,t1,t1 or t1,t2,t2,t2). The list of species appearing twice in some 4-taxon sets is stored in the output DataCF object. For these species, the length of their external edge is identifiable (in coalescent units). If multiple rows correspond to the same 4-taxon set, these rows are merged and their CF values (and number of genes) are averaged. If none of the species is repeated within any 4-taxon set, then this averaging is attempted only if <code>mergerows</code> is true.</p><pre><code class="nohighlight hljs">readTableCF!(DataCF, data frame, columns)</code></pre><p>Modify the <code>.quartet.obsCF</code> values in the <code>DataCF</code> object with those read from the data frame in columns numbered <code>columns</code>. <code>columns</code> should have <strong>3</strong> columns numbers for the 3 CFs in this order: <code>12_34</code>, <code>13_24</code> and <code>14_23</code>.</p><p>Assumptions:</p><ul><li>same 4-taxon sets in <code>DataCF</code> and in the data frame, and in the same order, but this assumption is <em>not checked</em> (for speed, e.g. during bootstrapping).</li><li>one single row per 4-taxon set (multiple individuals representatives of the same 4-taxon set should have been already merged); basically: the DataCF should have been created from the data frame by <code>readTableCF!(df, colums)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L231-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readTableCF-Tuple{AbstractString}" href="#SNaQ.readTableCF-Tuple{AbstractString}"><code>SNaQ.readTableCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readTableCF(file)
readTableCF(data frame)
readTableCF!(data frame)</code></pre><p>Read a file or DataFrame object containing a table of concordance factors (CF), with one row per 4-taxon set. The first 4 columns are assumed to give the labels of the 4 taxa in each set (tx1, tx2, tx3, tx4). Columns containing the CFs are assumed to be named <code>CF12_34</code>, <code>CF13_24</code> and <code>CF14_23</code>; or <code>CF12.34</code>, <code>CF13.24</code> and <code>CF14.23</code>; or else are assumed to be columns 5,6,7. If present, a column named &#39;ngenes&#39; will be used to get the number of loci used to estimate the CFs for each 4-taxon set.</p><p>Output: <a href="#SNaQ.DataCF"><code>DataCF</code></a> object</p><p>Optional arguments:</p><ul><li>summaryfile: if specified, a summary file will be created with that name.</li><li>delim (for the first form only): to specify how columns are delimited, with single quotes: delim=&#39;;&#39;. Default is a <code>csv</code> file, i.e. <code>delim=&#39;,&#39;</code>.</li><li><code>mergerows</code>: false by default. When true, will attempt to merge multiple rows corresponding to the same four-taxon set (by averaging their quartet CFs) even if none of the species is repeated within any row (that is, in any set of 4 taxa)</li></ul><p>The last version modifies the input data frame, if species are represented by multiple alleles for instance (see <a href="#SNaQ.readTableCF!-Tuple{DataCF, DataFrames.DataFrame, Vector{Int64}}"><code>readTableCF!</code></a>(data frame, columns)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L123-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readTopologyLevel1-Tuple{AbstractString}" href="#SNaQ.readTopologyLevel1-Tuple{AbstractString}"><code>SNaQ.readTopologyLevel1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readTopologyLevel1(filename)
readTopologyLevel1(parenthetical format)</code></pre><p>same as readTopology, reads a tree or network from parenthetical format, but this function enforces the necessary conditions for any starting topology in SNaQ: non-intersecting cycles, no polytomies, unrooted. It sets any missing branch length to 1.0.</p><p>If the network has a bad diamond II (in which edge lengths are γ&#39;s are not identifiable) and if the edge below this diamond has a length <code>t</code> different from 0, then this length is set back to 0 and the major parent hybrid edge is lengthened by <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readwrite.jl#L176-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.readTrees2CF-Tuple{AbstractString}" href="#SNaQ.readTrees2CF-Tuple{AbstractString}"><code>SNaQ.readTrees2CF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readTrees2CF(treefile)
readTrees2CF(vector of trees)</code></pre><p>Read trees in parenthetical format from a file, or take a vector of trees already read, and calculate the proportion of these trees having a given quartet (concordance factor: CF), for all quartets or for a sample of quartets. Optional arguments include:</p><ul><li>quartetfile: name of text file with list of 4-taxon subsets to be analyzed. If none is specified, the function will list all possible 4-taxon subsets.</li><li>whichQ=&quot;rand&quot;: to choose a random sample of 4-taxon subsets</li><li>numQ: size of random sample (ignored if whichQ is not set to &quot;rand&quot;)</li><li>writeTab=false: does not write the observedCF to a table (default true)</li><li>CFfile: name of file to save the observedCF (default tableCF.txt)</li><li>writeQ=true: save intermediate files with the list of all 4-taxon subsets and chosen random sample (default false).</li><li>writeSummary: write descriptive stats of input data (default: true)</li><li>nexus: if true, it assumes the gene trees are written in nexus file (default: false)</li></ul><p>See also: <a href="#SNaQ.countquartetsintrees"><code>countquartetsintrees</code></a>, which uses a much faster algorithm; <a href="#SNaQ.readTableCF-Tuple{AbstractString}"><code>readTableCF</code></a> to read a table of quartet CFs directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L1011-L1032">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}" href="#SNaQ.sameTaxa-Tuple{Quartet, HybridNetwork}"><code>SNaQ.sameTaxa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sameTaxa(Quartet, HybridNetwork)</code></pre><p>Return <code>true</code> if all taxa in the quartet are represented in the network, <code>false</code> if one or more taxa in the quartet does not appear in the network.</p><p>warning: the name can cause confusion. A more appropriate name might be &quot;in&quot;, or &quot;taxain&quot;, or &quot;taxonsubset&quot;, or etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L423-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sampleCFfromCI" href="#SNaQ.sampleCFfromCI"><code>SNaQ.sampleCFfromCI</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sampleCFfromCI(data frame, seed=0)
sampleCFfromCI!(data frame, seed=0)</code></pre><p>Read a data frame containing CFs and their credibility intervals, and sample new obsCF uniformly within the CIs. These CFs are then rescaled to sum up to 1 for each 4-taxon sets. Return a data frame with taxon labels in first 4 columns, sampled obs CFs in columns 5-7 and credibility intervals in columns 8-13.</p><ul><li>The non-modifying function creates a new data frame (with re-ordered columns) and returns it. If <code>seed=-1</code>, the new df is a deep copy of the input df, with no call to the random number generator. Otherwise, <code>seed</code> is passed to the modifying function.</li><li>The modifying function overwrites the input data frame with the sampled CFs and returns it. If <code>seed=0</code>, the random generator is seeded from the clock. Otherwise the random generator is seeded using <code>seed</code>.</li></ul><p>Warning: the modifying version does <em>not</em> check the data frame: assumes correct columns.</p><p>optional argument: <code>delim=&#39;,&#39;</code> by default: how columns are delimited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/bootstrap.jl#L7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}" href="#SNaQ.setGammaBLfromGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.setGammaBLfromGammaz!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setGammaBLfromGammaz!(node, network)</code></pre><p>Update the γ values of the two sister hybrid edges in a bad diamond I, given the <code>gammaz</code> values of their parent nodes, and update the branch lengths t1 and t2 of their parent edges (those across from the hybrid nodes), in such a way that t1=t2 and that these branch lengths and γ values are consistent with the <code>gammaz</code> values in the network.</p><p>Similar to the first section of <a href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>undoGammaz!</code></a>, but does not update anything else than γ and t&#39;s. Unlike <code>undoGammaz!</code>, no error if non-hybrid <code>node</code> or not at bad diamond I.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/auxiliary.jl#L143-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}" href="#SNaQ.setLength!-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, Number}"><code>SNaQ.setLength!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setLength!(edge, newlength)`</code></pre><p>Set the length of <code>edge</code>, and set <code>edge.y</code> and <code>edge.z</code> accordingly. Warning: specific to <code>SNaQ.jl</code>. Consider <code>PhyloNetworks.setlengths!</code> for a more generic tool.</p><ul><li>The new length is censored to 10: if the new length is above 10, the edge&#39;s length will be set to 10. Lengths are interpreted in coalescent units, and 10 is close to infinity: near perfect gene tree concordance. 10 is used as an upper limit to coalescent units that can be reliably estimated.</li><li>The new length is allowed to be negative, but must be greater than -log(1.5), to ensure that the major quartet concordance factor (1 - 2/3 exp(-length)) is &gt;= 0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/auxiliary.jl#L125-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.setNonIdBL!-Tuple{HybridNetwork}" href="#SNaQ.setNonIdBL!-Tuple{HybridNetwork}"><code>SNaQ.setNonIdBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>setNonIdBL!(net)</code></p><p>Set non-identifiable edge branch lengths to -1.0 (i.e. missing) for a level-1 network <code>net</code>, except for edges in</p><ul><li>a good triangle: the edge below the hybrid is constrained to 0.</li><li>a bad diamond II: the edge below the hybrid is constrained to 0</li><li>a bad diamond I: the edges across from the hybrid node have non identifiable lengths but are kept, because the two γ*(1-exp(-t)) values are identifiable.</li></ul><p>will break if <code>inCycle</code> attributes are not initialized (at -1) or giving a correct node number.</p><p>see <a href="https://juliaphylo.github.io/PhyloNetworks.jl/stable/lib/internals/#PhyloNetworks.Node"><code>PhyloNetworks.Node</code></a> for the meaning of boolean attributes <code>isBadTriangle</code> (which corresponds to a &quot;good&quot; triangle above), <code>isBadDiamondI</code> and <code>isBadDiamondII</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/descriptive.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.snaq!-Tuple{HybridNetwork, DataCF}" href="#SNaQ.snaq!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.snaq!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">snaq!(T::HybridNetwork, d::DataCF)</code></pre><p>Estimate the network (or tree) to fit observed quartet concordance factors (CFs) stored in a DataCF object, using maximum pseudo-likelihood. A level-1 network is assumed. The search starts from topology <code>T</code>, which can be a tree or a network with no more than <code>hmax</code> hybrid nodes. The function name ends with ! because it modifies the CF data <code>d</code> by updating its attributes <code>expCF</code>: CFs expected under the network model. It does <em>not</em> modify <code>T</code>. The quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Output:</p><ul><li>estimated network in file <code>.out</code> (also in <code>.log</code>): best network overall and list of networks from each individual run.</li><li>the best network and modifications of it, in file <code>.networks</code>. All networks in this file have the same undirected topology as the best network, but have different hybrid/gene flow directions. These other networks are reported with their pseudo-likelihood scores, because  non-identifiability issues can cause them to have very similar scores, and because  SNaQ was shown to estimate the undirected topology accurately but not the direction of  hybridization in cases of near non-identifiability.</li><li>if any error occurred, file <code>.err</code> provides information (seed) to reproduce the error.</li></ul><p>There are many optional arguments, including</p><ul><li><code>hmax</code> (default 1): maximum number of hybridizations allowed</li><li><code>verbose</code> (default false): if true, print information about the numerical optimization</li><li><code>runs</code> (default 10): number of independent starting points for the search</li><li><code>outgroup</code> (default none): outgroup taxon to root the estimated topology at the very end</li><li><code>filename</code> (default &quot;snaq&quot;): root name for the output files (<code>.out</code>, <code>.err</code>). If empty (&quot;&quot;), files are <em>not</em> created, progress log goes to the screen only (standard out).</li><li><code>seed</code> (default 0 to get it from the clock): seed to replicate a given search</li><li><code>probST</code> (default 0.3): probability to start from <code>T</code> at each given run. With problability 1-probST, the search is started from an NNI modification of <code>T</code> along a tree edge with no hybrid neighbor, with a possible modification of one reticulation if <code>T</code> has one.</li><li><code>updateBL</code> (default true): If true and if <code>T</code> is a tree, the branch lengths in <code>T</code> are first optimized roughly with <a href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>updateBL!</code></a> by using the average CF of all quartets defining each branch and back-calculating the coalescent units.</li></ul><p>The following optional arguments control when to stop the optimization of branch lengths and γ&#39;s on each individual candidate network. Defaults are in parentheses:</p><ul><li><code>ftolRel</code> (1e-6) and <code>ftolAbs</code> (1e-6): relative and absolute differences of the network score between the current and proposed parameters,</li><li><code>xtolRel</code> (1e-2) and <code>xtolAbs</code> (1e-3): relative and absolute differences between the current and proposed parameters.</li></ul><p>Greater values will result in a less thorough but faster search. These parameters are used when evaluating candidate networks only. The following optional arguments control when to stop proposing new network topologies:</p><ul><li><code>Nfail</code> (75): maximum number of times that new topologies are proposed and rejected (in a row).</li><li><code>liktolAbs</code> (1e-6): the proposed network is accepted if its score is better than the current score by at least liktolAbs.</li></ul><p>Lower values of <code>Nfail</code> and greater values of <code>liktolAbs</code> and <code>ftolAbs</code> would result in a less thorough but faster search.</p><p>At the end, branch lengths and γ&#39;s are optimized on the last &quot;best&quot; network with different and very thorough tolerance parameters: 1e-12 for ftolRel, 1e-10 for ftolAbs, xtolRel, xtolAbs.</p><p>See also: <a href="#SNaQ.topologyMaxQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>topologyMaxQPseudolik!</code></a> to optimize parameters on a fixed topology, and <a href="#SNaQ.topologyQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>topologyQPseudolik!</code></a> to get the deviance (pseudo log-likelihood up to a constant) of a fixed topology with fixed parameters.</p><p>Reference:   Claudia Solís-Lemus and Cécile Ané (2016). Inferring phylogenetic networks with maximum pseudolikelihood under incomplete lineage sorting. <a href="http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1005896">PLoS Genetics</a> 12(3):e1005896</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L1796-L1870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sort_stringasinteger!-Tuple{Any}" href="#SNaQ.sort_stringasinteger!-Tuple{Any}"><code>SNaQ.sort_stringasinteger!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_stringasinteger!(taxa)</code></pre><p>Sort a vector of strings <code>taxa</code>, numerically if elements can be parsed as an integer, alphabetically otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L480-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.sorttaxa!-Tuple{DataCF}" href="#SNaQ.sorttaxa!-Tuple{DataCF}"><code>SNaQ.sorttaxa!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sorttaxa!(DataFrame, columns)</code></pre><p>Reorder the 4 taxa and reorders the observed concordance factors accordingly, on each row of the data frame. If <code>columns</code> is ommitted, taxon names are assumed to be in columns 1-4 and CFs are assumed to be in columns 5-6 with quartets in this order: <code>12_34</code>, <code>13_24</code>, <code>14_23</code>. Does <strong>not</strong> reorder credibility interval values, if present.</p><pre><code class="nohighlight hljs">sorttaxa!(DataCF)
sorttaxa!(Quartet, permutation_tax, permutation_cf)</code></pre><p>Reorder the 4 taxa in each element of the DataCF <code>quartet</code>. For a given Quartet, reorder the 4 taxa in its fields <code>taxon</code> and <code>qnet.quartetTaxon</code> (if non-empty) and reorder the 3 concordance values accordingly, in <code>obsCF</code> and <code>qnet.expCF</code>.</p><p><code>permutation_tax</code> and <code>permutation_cf</code> should be vectors of short integers (Int8) of length 4 and 3 respectively, whose memory allocation gets reused. Their length is <em>not checked</em>.</p><p><code>qnet.names</code> is unchanged: the order of taxon names here relates to the order of nodes in the network (???)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/auxiliary.jl#L358-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.summarizeDataCF-Tuple{DataCF}" href="#SNaQ.summarizeDataCF-Tuple{DataCF}"><code>SNaQ.summarizeDataCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>summarizeDataCF(d::DataCF)</code></p><p>function to summarize the information contained in a DataCF object. It has the following optional arguments:</p><ul><li>filename: if provided, the summary will be saved in the filename, not to screen</li><li>pc (number between (0,1)): threshold of percentage of missing genes to identify 4-taxon subsets with fewer genes than the threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L1143-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}" href="#SNaQ.taxadiff-Tuple{Vector{Quartet}, HybridNetwork}"><code>SNaQ.taxadiff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">taxadiff(Vector{Quartet}, network; multiplealleles=true)
taxadiff(DataCF, network; multiplealleles=true)</code></pre><p>Return 2 vectors:</p><ul><li>taxa in at least 1 of the quartets but not in the network, and</li><li>taxa in the network but in none of the quartets.</li></ul><p>When <code>multiplealleles</code> is true, the taxon names that end with &quot;__2&quot; are ignored in the quartets: they are not expected to appear in the networks that users give as input, or get as output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L440-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.topologyMaxQPseudolik!-Tuple{HybridNetwork, DataCF}" href="#SNaQ.topologyMaxQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.topologyMaxQPseudolik!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>topologyMaxQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Estimate the branch lengths and inheritance probabilities (γ&#39;s) for a given network topology. The network is <em>not</em> modified, only the object <code>d</code> is, with updated expected concordance factors.</p><p>Ouput: new network, with optimized parameters (branch lengths and gammas). The maximized quartet pseudo-deviance is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0. This is also an attribute of the network, which can be accessed with <code>net.loglik</code>.</p><p>Optional arguments (default value):</p><ul><li>verbose (false): if true, information on the numerical optimization is printed to screen</li><li>ftolRel (1e-5), ftolAbs (1e-6), xtolRel (1e-3), xtolAbs (1e-4): absolute and relative tolerance values for the pseudo-deviance function and the parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/snaq_optimization.jl#L409-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.topologyQPseudolik!-Tuple{HybridNetwork, DataCF}" href="#SNaQ.topologyQPseudolik!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.topologyQPseudolik!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>topologyQPseudolik!(net::HybridNetwork, d::DataCF)</code></p><p>Calculate the quartet pseudo-deviance of a given network/tree for DataCF <code>d</code>. This is the negative log pseudo-likelihood, up to an additive constant, such that a perfect fit corresponds to a deviance of 0.0.</p><p>Be careful if the net object does not have all internal branch lengths specified because then the pseudolikelihood will be meaningless.</p><p>The loglik attribute of the network is undated, and <code>d</code> is updated with the expected concordance factors under the input network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/pseudolik.jl#L1296-L1309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}" href="#SNaQ.traverseContainRoot!-Tuple{PhyloNetworks.Node, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Vector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Vector{Bool}}"><code>SNaQ.traverseContainRoot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/update.jl#L83-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}" href="#SNaQ.undirectedOtherNetworks-Tuple{HybridNetwork}"><code>SNaQ.undirectedOtherNetworks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undirectedOtherNetworks(net::HybridNetwork)</code></pre><p>Return a vector of HybridNetwork objects, obtained by switching the placement of each hybrid node to other nodes inside its cycle. This amounts to changing the direction of a gene flow event (recursively to move around the whole cycle of each reticulation).</p><p>Optional argument: <code>outgroup</code>, as a String. If an outgroup is specified, then networks conflicting with the placement of the root are avoided.</p><p>Assumptions: <code>net</code> is assumed to be of level 1, that is, each blob has a single cycle with a single reticulation. All level-1 fields of <code>net</code> are assumed up-to-date.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; net = readTopology(&quot;(A:1.0,((B:1.1,#H1:0.2::0.2):1.2,(((C:0.52,(E:0.5)#H2:0.02::0.7):0.6,(#H2:0.01::0.3,F:0.7):0.8):0.9,(D:0.8)#H1:0.3::0.8):1.3):0.7):0.1;&quot;);
julia&gt; vnet = undirectedOtherNetworks(net)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/manipulateNet.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}" href="#SNaQ.undoGammaz!-Tuple{PhyloNetworks.Node, HybridNetwork}"><code>SNaQ.undoGammaz!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undoGammaz!(node, network)</code></pre><p>Undo <code>updateGammaz!</code> for the 2 cases: bad diamond I,II. <code>node</code> should be a hybrid node. Set length to edges that were not identifiable and change edges&#39; <code>gammaz</code> attribute to -1.0. Recalculate branch lengths in terms of <code>gammaz</code>.   <em>warning</em>: needs to know <code>incycle</code> attributes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/undo.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}" href="#SNaQ.updateBL!-Tuple{HybridNetwork, DataCF}"><code>SNaQ.updateBL!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateBL!(net::HybridNetwork, d::DataCF)</code></pre><p>Update internal branch lengths of <code>net</code> based on the average quartet concordance factor (CF) across all quartets that exactly correspond to a given branch: new branch length = <code>-log(3/2(1-mean(CF observed in d)))</code>. <code>net</code> is assumed to be a tree, such that the above equation holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L1162-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.updateContainRoot!" href="#SNaQ.updateContainRoot!"><code>SNaQ.updateContainRoot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateContainRoot!(HybridNetwork, Node)
traverseContainRoot!(Node, Edge, edges_changed::Array{Edge,1}, rightDir::Vector{Bool})</code></pre><p>The input <code>node</code> to <code>updateContainRoot!</code> must be a hybrid node (can come from searchHybridNode). <code>updateContainRoot!</code> starts at the input node and calls <code>traverseContainRoot!</code>, which traverses the network recursively. By default, containRoot attributes of edges are true. Changes <code>containRoot</code> to false for all the visited edges: those below the input node, but not beyond any other hybrid node.</p><p><code>updateContainRoot!</code> Returns a <code>flag</code> and an array of edges whose containRoot has been changed from true to false. <code>flag</code> is false if the set of edges to place the root is empty</p><p>In <code>traverseContainRoot!</code>, <code>rightDir</code> turns false if hybridizations have incompatible directions (vector of length 1, to be modified).</p><p>Warning:</p><ul><li>does <em>not</em> update <code>containRoot</code> of minor hybrid edges.</li><li>assumes correct <code>isMajor</code> attributes: to stop the recursion at minor hybrid edges.</li><li>assumes correct hybrid attributes of both nodes &amp; edges: to check if various hybridizations have compatible directions. For each hybrid node that is encountered, checks if it was reached via a hybrid edge (ok) or tree edge (not ok).</li></ul><p><code>rightDir</code>: vector of length 1 boolean, to be mutable and modified by the function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/update.jl#L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.writeTableCF-Tuple{Vector{Quartet}}" href="#SNaQ.writeTableCF-Tuple{Vector{Quartet}}"><code>SNaQ.writeTableCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writeTableCF(vector of Quartet objects)
writeTableCF(DataCF)</code></pre><p>Build a DataFrame containing observed quartet concordance factors, with columns named:</p><ul><li><code>t1</code>, <code>t2</code>, <code>t3</code>, <code>t4</code> for the four taxon names in each quartet</li><li><code>CF12_34</code>, <code>CF13_24</code>, <code>CF14_23</code> for the 3 quartets of a given four-taxon set</li><li><code>ngenes</code> if this information is available for some quartets</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.writeTableCF-Union{Tuple{Array{SNaQ.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{SNaQ.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}" href="#SNaQ.writeTableCF-Union{Tuple{Array{SNaQ.QuartetT{T}, 1}}, Tuple{T}, Tuple{Array{SNaQ.QuartetT{T}, 1}, AbstractVector{&lt;:AbstractString}}} where T&lt;:Union{StaticArraysCore.StaticArray{Tuple{3}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{4}, T, 1} where T, StaticArraysCore.StaticArray{Tuple{3, N}, T, 2} where {N, T}}"><code>SNaQ.writeTableCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writeTableCF(quartetlist::Vector{QuartetT} [, taxonnames]; colnames)</code></pre><p>Convert a vector of <a href="#SNaQ.QuartetT"><code>QuartetT</code></a> objects to a data frame, with 1 row for each four-taxon set in the list. Each four-taxon set contains quartet data of some type <code>T</code>, which determines the number of columns in the data frame. This data type <code>T</code> should be a vector of length 3 or 4, or a 3×n matrix.</p><p>In the output data frame, the columns are, in this order:</p><ul><li><code>qind</code>: contains the quartet&#39;s <code>number</code></li><li><code>t1, t2, t3, t4</code>: contain the quartet&#39;s <code>taxonnumber</code>s if no <code>taxonnames</code> are given, or the taxon names otherwise. The name of taxon number <code>i</code> is taken to be <code>taxonnames[i]</code>.</li><li>3 columns for each column in the quartet&#39;s <code>data</code>. The first 3 columns are named <code>CF12_34, CF13_24, CF14_23</code>. The next columns are named <code>V2_12_34, V2_13_24, V2_14_23</code> and contain the data in the second column of the quartet&#39;s data matrix. And so on. For the data frame to have non-default column names, provide the desired 3, 4, or 3×n names as a vector via the optional argument <code>colnames</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readData.jl#L44-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SNaQ.writeTopologyLevel1-Tuple{HybridNetwork}" href="#SNaQ.writeTopologyLevel1-Tuple{HybridNetwork}"><code>SNaQ.writeTopologyLevel1</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>writeTopologyLevel1(net::HybridNetwork)</code></p><p>Write the extended Newick parenthetical format of a level-1 network object with many optional arguments (see below). Makes a deep copy of net: does <em>not</em> modify <code>net</code>.</p><ul><li>di=true: write in format for Dendroscope (default false)</li><li>namelabel=true: If <code>namelabel</code> is true, taxa are labelled by their names;</li></ul><p>otherwise taxa are labelled by their numbers (unique identifiers).</p><ul><li>outgroup (string): name of outgroup to root the tree/network. if &quot;none&quot; is given, the root is placed wherever possible.</li><li>printID=true, only print branch lengths for identifiable egdes according to the snaq estimation procedure (default false) (true inside of <code>snaq!</code>.)</li><li>round: rounds branch lengths and heritabilities γ (default: true)</li><li>digits: digits after the decimal place for rounding (defult: 3)</li><li>string: if true (default), returns a string, otherwise returns an IOBuffer object.</li><li>multall: (default false). set to true when there are multiple alleles per population.</li></ul><p>The topology may be written using a root different than net.root, if net.root is incompatible with one of more hybrid node. Missing hybrid names are written as &quot;#Hi&quot; where &quot;i&quot; is the hybrid node number if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPhylo/SNaQ.jl/blob/cab4f1e1e21329f5097473df836a81ed7b188f98/src/readwrite.jl#L309-L334">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 29 October 2024 20:40">Tuesday 29 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
